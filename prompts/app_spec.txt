<project_specification>
  <project_name>Monster Workshop</project_name>

  <overview>
    A cooperative crafting game with a traditional roguelike/ASCII aesthetic using pyunicodegame for beautiful unicode graphics with particles, animations, and effects. Players control monsters in a persistent 2D grid world, optimizing production lines by physically pushing items around in a Sokoban-like manner. The game uses MonsterMakers economy mechanics (renown, skills, crafting) but embodies them in a physical world where crafting means pushing ingredients into workshops, and everything exists as tangible objects on the grid. "Sharing is good" - the game encourages cooperation through shared workshops and items that benefit all contributors via the share distribution system.
  </overview>

  <technology_stack>
    <frontend>
      <framework>Python + pyunicodegame</framework>
      <rendering>Unicode TUI-style graphics with sprites, animations, particles, bloom, lighting</rendering>
      <font>Unifont (8x16 duospace, full Unicode coverage)</font>
      <note>Frontend is rendering ONLY - no game logic client-side. All logic is server-authoritative.</note>
    </frontend>
    <backend>
      <framework>Python + gridtickmultiplayer architecture</framework>
      <runtime>Python 3.11+</runtime>
      <async>asyncio</async>
      <websockets>FastAPI WebSocket support</websockets>
      <database>SQLite (via aiosqlite)</database>
      <orm>SQLAlchemy (async)</orm>
      <game_logic>Custom game module implementing GameLogicModule protocol</game_logic>
    </backend>
    <communication>
      <realtime>WebSocket for game state and intents</realtime>
      <rest>REST endpoints for auth, zone listing, debug tools</rest>
      <protocol>JSON messages</protocol>
      <security>Server-authoritative - clients can only send intents, server validates everything</security>
    </communication>
  </technology_stack>

  <prerequisites>
    <environment_setup>
      - Python 3.11 or higher
      - Virtual environment (venv or similar)
      - pygame (for pyunicodegame)
      - fastapi, uvicorn, websockets, sqlalchemy, aiosqlite, pydantic, passlib
      - pyunicodegame library (from github/pyunicodegame)
      - gridtickmultiplayer framework (from github/gridtickmultiplayer)
    </environment_setup>
  </prerequisites>

  <feature_count>171</feature_count>

  <time_system>
    <time_scale>1 real second = 30 game seconds (configurable via GAME_TIME_MULTIPLIER constant)</time_scale>
    <tick_rate>1 second (from gridtickmultiplayer)</tick_rate>
    <offline_progression>Monsters continue auto-repeating while player is logged out</offline_progression>
  </time_system>

  <architecture_principles>
    <principle name="Server Authoritative">
      All game logic runs on the server. Clients send intents, server validates and executes.
      Players cannot cheat by sending malicious WebSocket messages.
    </principle>
    <principle name="Data-Driven">
      Towns, workshops, tech tree, monster types, zone layouts all stored as pure data.
      Easy to iterate on content without code changes.
    </principle>
    <principle name="Physical Embodiment">
      Everything exists as objects on the grid. Crafting = pushing items. No abstract menus.
      The Sokoban-like pushing IS the interface.
    </principle>
    <principle name="Sharing Is Good">
      Anyone can use anyone's workshop or items. Using another player's resources benefits
      them via share distribution. No need for explicit trade systems.
    </principle>
    <principle name="Polish From Day One">
      Heavy use of pyunicodegame effects, animations, particles. Intuitive and fun.
      Someone should be able to pick this up and play intuitively.
    </principle>
  </architecture_principles>

  <grid_system>
    <cell_size>8x16 pixels (one narrow unicode character)</cell_size>
    <standard_item_size>2 cells wide (16x16 pixels, double-width unicode chars like emoji)</standard_item_size>
    <multi_cell_items>Supported for larger objects (wagons, workshops)</multi_cell_items>
    <push_mechanics>
      - Everything moves one cell at a time
      - Collision detection accounts for varying item/monster sizes
      - Monsters can push items but not other monsters actively pushing
    </push_mechanics>
    <no_stacking>One item per cell (multi-cell items occupy their cells)</no_stacking>
  </grid_system>

  <viewport>
    <width>60 cells</width>
    <height>20 cells</height>
    <camera>Scrollable, auto-follows monster if it goes off-screen</camera>
    <ui_panels>Two info panels on the left side (object info + monster skills), fixed position</ui_panels>
  </viewport>

  <security_and_access_control>
    <user_roles>
      <role name="player">
        <permissions>
          - Can register and login
          - Can connect via WebSocket
          - Can control their own monsters
          - Can push items (except items another player is actively pushing)
          - Can use any workshop
          - Can submit intents for their monsters
          - Can receive tick state updates
        </permissions>
      </role>
      <role name="debug">
        <permissions>
          - All player permissions
          - Can pause/resume tick engine
          - Can inspect zone state
          - Can inspect entity state
          - Can view connected players
        </permissions>
        <note>Debug access is for development only</note>
      </role>
    </user_roles>
    <authentication>
      <method>Username/password with session tokens</method>
      <session_timeout>Configurable, default none (persistent until logout)</session_timeout>
      <password_requirements>Minimum 8 characters</password_requirements>
    </authentication>
    <item_protection>
      Only rule: Cannot push an item another player is actively pushing.
      Physical possession determines ownership for crafting/scoring.
    </item_protection>
  </security_and_access_control>

  <core_features>
    <authentication_and_account>
      - Player registration with username and password
      - Player login returning session token
      - Player logout invalidating session
      - Session validation for WebSocket connections
      - Commune creation (player's "account" for monsters and renown)
    </authentication_and_account>

    <monster_system>
      - Monster selection screen (shown on game start and when switching)
      - Five monster types from MonsterMakers: Cyclops, Elf, Goblin, Orc, Troll
      - Six ability scores: STR, DEX, CON, INT, WIS, CHA (1-18 scale)
      - Equipment slots with body/mind fitting capacity
      - Three transferable skills chosen at creation
      - Applied skills (learned through work, 0-1 scale)
      - Specific skills (one per exact good type)
      - Skill learning formulas from MonsterMakers
      - Skill forgetting when not used (WIS reduces rate)
      - Monster aging: +1 all stats at 30 days, +2 at 60 days
      - Monster upkeep cost every 28 days
      - Cost multiplier: spending renown increases future costs
      - Monster visual: gentle idle bob animation, more vigorous bob while working
    </monster_system>

    <world_navigation>
      - Zone rendering with camera system
      - Scrollable viewport (60x20 cells)
      - Auto-follow when monster goes off-screen
      - Monster movement (one cell at a time)
      - Collision detection with varying entity sizes
      - Zone transitions via explicit roads/paths
      - Signposts showing destination zone names
    </world_navigation>

    <environment_and_world_zones>
      - Multiple connected zones (villages + wilderness)
      - Zone types: Villages (workshops, storage), Wilderness (travel routes, rare items), Raw material areas
      - Regional specialization (certain materials/workshops only in certain towns)
      - Grid-based terrain with walkable vs blocked cells
      - Roads/paths between zones with signposts
      - Gathering spots for raw materials (wells, mines, forests, fields)
      - Dispensers/storage areas in towns
      - Delivery/scoring locations (fixed buildings in towns)
      - Wilderness requires wagon/hauling skills for effective cargo transport
      - Rare items only available in wilderness
      - Zone data stored as pure data (easy to edit/create new zones)
    </environment_and_world_zones>

    <grid_and_items>
      - Item rendering with double-width unicode characters (16x16 pixels)
      - Multi-cell items supported (wagons, large objects)
      - Pushing mechanics with size-aware collision
      - Items move one cell at a time regardless of size
      - No item stacking (one item per cell)
      - Item quality shown via brightness (brighter = better)
      - Exceptional quality items have emissive glow
      - Durability shown via red tint or indicator bar
      - Dispensers: hold one item type, push in to deposit, push visible item out
      - Wagon mechanics: hitch and pull (different from pushing single items)
      - Weight system from MonsterMakers (affects transport capacity)
    </grid_and_items>

    <workshops_and_crafting>
      - Workshops are 4x4+ walk-into spaces
      - Input slots inside workshop (push ingredients here)
      - Output slots inside workshop (finished goods appear here)
      - Tool slots in workshop (tools wear out, auto-repeat stops when depleted)
      - Recipe selection via small popup list (press number to select)
      - Recording system for batch crafting:
        1. Set goal: interact with workshop, select recipe, recording starts
        2. Fetch: walk to dispensers, push ingredients back (exact path recorded)
        3. Deposit: push items into workshop slots
        4. Craft: workshop processes, output appears, recording ends
        5. Repeat: single key replays exact movements
      - Auto-repeat stops if any ingredient runs out or tool depleted
      - Crafting delay based on MonsterMakers formulas (DEX, INT, equipment)
      - Monsters can path through other monsters/items with auto-wait if blocked
      - Full MonsterMakers tech tree (~80+ good types) loaded as data
    </workshops_and_crafting>

    <visual_effects>
      - Crafting running: minor particles (craft-type based) + pulsing monster + progress bar
      - Crafting complete: celebration effect (sparkle burst)
      - Item deposited: brief flash on the slot
      - Quality visualization: brightness indicates quality, emissive glow for exceptional
      - Durability visualization: red tint or indicator bar (not dimming)
      - Monster idle: gentle bobbing animation
      - Monster working: more vigorous bobbing animation
      - Particle emitters for workshops (sparks, steam, magic glow by craft type)
      - Bloom post-processing for glowing effects
    </visual_effects>

    <economy_and_progression>
      - Renown system: score goods at delivery locations for renown
      - Share distribution: all contributors get credit (producers, tool makers, transporters)
      - Upkeep system: 28-day cycle, monsters cost renown upkeep
      - Cost multiplier: spending renown increases future monster/equipment costs
      - Skill learning: improves while working (INT bonus)
      - Skill forgetting: decays when not used (WIS reduces rate)
      - Monster aging bonuses: +1 all stats at 30 days, +2 at 60 days
      - Physical possession determines ownership (no checkout system)
      - Value calculation based on MonsterMakers formulas (quality, depth, CHA)
    </economy_and_progression>

    <multiplayer>
      - See other players' monsters in the world
      - See other players' items and pushing actions
      - Active-push protection: can't push what someone else is actively pushing
      - Shared workshops: anyone can use any workshop (benefits owner via shares)
      - Persistent world: monsters continue auto-repeating while logged out
      - WebSocket communication for real-time updates
      - Zone subscription system from gridtickmultiplayer
    </multiplayer>

    <ui_panels>
      - Object info panel (left side): name, quality, durability, contents for selected item/workshop
      - Monster skills panel (left side): ability scores, relevant skills, equipment
      - Speech bubbles for in-world text (monster thoughts, system messages, tutorial hints)
      - Error/warning feedback: speech bubble and/or brief red flash
      - Minimal menus: only recipe selection popup and monster selection screen
    </ui_panels>

    <tech_tree_data>
      - Load full MonsterMakers tech tree (~80+ good types)
      - Good types include: textiles, dyes, ceramics, metals, raw materials, tools
      - Each good type has: tags, storage volume, quality flag, production time, skills, tools
      - Workshop types with task slots and task tags
      - Raw material locations with rarity and gathering requirements
      - All data stored as pure data for easy iteration
    </tech_tree_data>
  </core_features>

  <monster_types>
    <type name="Cyclops" cost="100" body_cap="100" mind_cap="100">
      High STR (18), High CON (16). Good for heavy labor and transport.
    </type>
    <type name="Elf" cost="150" body_cap="50" mind_cap="150">
      High INT (18), High DEX (16). Good for skilled crafting and learning.
    </type>
    <type name="Goblin" cost="50" body_cap="150" mind_cap="50">
      High DEX (18), High CHA (16). Good for fast production and value bonuses.
    </type>
    <type name="Orc" cost="2000" body_cap="150" mind_cap="50">
      High STR (16), High CON (18). Premium worker for demanding tasks.
    </type>
    <type name="Troll" cost="1" body_cap="1500" mind_cap="1500">
      Massive equipment capacity (100 slots each). Specialist for equipped work.
    </type>
  </monster_types>

  <ability_scores>
    <ability name="STR" primary="Bonus to quantity produced" secondary="Small quality bonus"/>
    <ability name="DEX" primary="Reduces production task time" secondary="Small quantity bonus"/>
    <ability name="CON" primary="Reduces transport time" secondary="Small quality bonus"/>
    <ability name="INT" primary="Bonus to learning skills" secondary="Small production time reduction"/>
    <ability name="WIS" primary="Bonus to quality" secondary="Small forgetting reduction"/>
    <ability name="CHA" primary="Bonus to good value" secondary="Small transport time reduction"/>
  </ability_scores>

  <database_schema>
    <tables>
      <players>
        - id (UUID, primary key)
        - username (unique, indexed)
        - password_hash
        - created_at
        - last_login
      </players>

      <sessions>
        - id (UUID, primary key)
        - player_id (foreign key)
        - token (unique, indexed)
        - created_at
        - expires_at (nullable)
      </sessions>

      <communes>
        - id (UUID, primary key)
        - player_id (foreign key)
        - name
        - renown
        - total_renown_spent
        - created_at
      </communes>

      <monsters>
        - id (UUID, primary key)
        - commune_id (foreign key)
        - monster_type (Cyclops, Elf, Goblin, Orc, Troll)
        - name
        - str, dex, con, int, wis, cha (ability scores)
        - body_fitting_used, mind_fitting_used
        - transferable_skills (JSON array of 3)
        - applied_skills (JSON object: skill_name -> value)
        - specific_skills (JSON object: good_type -> value)
        - created_at (for aging calculation)
        - current_zone_id
        - x, y (position)
        - current_task (JSON: recording, auto-repeat state, etc.)
      </monsters>

      <zones>
        - id (UUID, primary key)
        - name (unique, indexed)
        - zone_type (village, wilderness, raw_material)
        - width, height
        - terrain_data (JSON grid of terrain types)
        - metadata (JSON for zone-specific data)
      </zones>

      <entities>
        - id (UUID, primary key)
        - zone_id (foreign key, indexed)
        - entity_type (item, workshop, dispenser, gathering_spot, signpost, delivery)
        - x, y (position)
        - width, height (in cells)
        - owner_id (nullable, for share tracking)
        - metadata (JSON: quality, durability, contents, good_type, etc.)
        - created_at
        - updated_at
      </entities>

      <good_types>
        - id (primary key)
        - name
        - type_tags (JSON array)
        - storage_volume
        - has_quality, is_fixed_quantity
        - requires_workshop
        - relevant_ability_score
        - transferable_skills (JSON array)
        - primary_applied_skill
        - secondary_applied_skills (JSON array)
        - difficulty_rating
        - production_time
        - value_added_shares
        - quantity
        - input_goods_tags_required (JSON)
        - tools_required_tags (JSON)
        - tools_weights (JSON)
        - raw_material_base_value (nullable)
        - raw_material_rarity (nullable)
        - raw_material_density (nullable)
      </good_types>

      <equipment_types>
        - id (primary key)
        - name
        - cost
        - body_fitting, mind_fitting
        - slot_type (worn, personal, internal)
        - effect (JSON: stat bonuses, production bonuses, etc.)
      </equipment_types>

      <shares>
        - id (UUID, primary key)
        - entity_id (foreign key to the good)
        - commune_id (foreign key)
        - share_count
        - contribution_type (producer, tool_creator, transporter, input_supplier)
      </shares>
    </tables>
  </database_schema>

  <api_endpoints_summary>
    <rest_auth>
      - POST /api/auth/register
      - POST /api/auth/login
      - POST /api/auth/logout
      - GET /api/auth/me
    </rest_auth>

    <rest_zones>
      - GET /api/zones
      - GET /api/zones/{zone_id}
    </rest_zones>

    <rest_debug>
      - POST /api/debug/tick/pause
      - POST /api/debug/tick/resume
      - POST /api/debug/tick/step
      - GET /api/debug/zones/{zone_id}/state
      - GET /api/debug/entities/{entity_id}
      - GET /api/debug/connections
    </rest_debug>

    <websocket>
      - WS /ws (main game connection)
    </websocket>

    <websocket_messages_client_to_server>
      - {"type": "subscribe", "zone_id": "..."}
      - {"type": "intent", "data": {"action": "move", "direction": "up"}}
      - {"type": "intent", "data": {"action": "push", "direction": "right"}}
      - {"type": "intent", "data": {"action": "interact"}}
      - {"type": "intent", "data": {"action": "select_recipe", "recipe_id": "..."}}
      - {"type": "intent", "data": {"action": "start_recording"}}
      - {"type": "intent", "data": {"action": "stop_recording"}}
      - {"type": "intent", "data": {"action": "start_autorepeat"}}
      - {"type": "intent", "data": {"action": "stop_autorepeat"}}
      - {"type": "intent", "data": {"action": "switch_monster", "monster_id": "..."}}
      - {"type": "intent", "data": {"action": "hitch_wagon"}}
      - {"type": "intent", "data": {"action": "unhitch_wagon"}}
    </websocket_messages_client_to_server>

    <websocket_messages_server_to_client>
      - {"type": "subscribed", "zone_id": "..."}
      - {"type": "tick", "tick_number": N, "state": {...}}
      - {"type": "error", "message": "..."}
      - {"type": "monster_list", "monsters": [...]}
      - {"type": "recipe_list", "recipes": [...]}
    </websocket_messages_server_to_client>
  </api_endpoints_summary>

  <game_logic_module>
    <description>
      The game logic module implements the GameLogicModule protocol from gridtickmultiplayer.
      All Monster Workshop game rules are implemented here, including:
      - Movement and pushing mechanics with size-aware collision
      - Crafting system with recording/playback
      - Skill learning and forgetting
      - Economy (renown, shares, upkeep)
      - Workshop processing
      - Transport mechanics
      - Monster switching
      - Auto-repeat execution
    </description>
    <key_methods>
      - on_init(): Load tech tree, create initial zones if needed
      - on_tick(): Process all intents, update crafting progress, apply skill changes, handle auto-repeat
      - get_player_state(): Return visible entities for the player's current zone and viewport
    </key_methods>
  </game_logic_module>

  <implementation_steps>
    <step number="1">
      <title>Project Setup and Core Infrastructure</title>
      <tasks>
        - Set up Python project with both frontend and backend
        - Integrate pyunicodegame for rendering
        - Integrate gridtickmultiplayer for backend
        - Configure database with SQLAlchemy models
        - Set up WebSocket communication between client and server
        - Implement basic authentication
      </tasks>
    </step>

    <step number="2">
      <title>Grid System and Rendering</title>
      <tasks>
        - Implement cell-based grid (8x16 cells)
        - Render double-width items (16x16)
        - Implement multi-cell entity support
        - Set up viewport (60x20) with scrolling camera
        - Implement UI panels on left side
        - Add basic sprite rendering for entities
      </tasks>
    </step>

    <step number="3">
      <title>Monster System</title>
      <tasks>
        - Implement monster types with ability scores
        - Create monster selection screen
        - Implement monster movement (one cell at a time)
        - Add idle/working animations (bobbing)
        - Implement monster switching between controlled monsters
        - Add skill and stat display in UI panel
      </tasks>
    </step>

    <step number="4">
      <title>Pushing Mechanics</title>
      <tasks>
        - Implement basic push (monster pushes single item)
        - Add size-aware collision detection
        - Implement active-push protection (can't push what others are pushing)
        - Add wagon mechanics (hitch and pull)
        - Implement path-through with auto-wait for blocked paths
      </tasks>
    </step>

    <step number="5">
      <title>Zones and Navigation</title>
      <tasks>
        - Implement zone loading from data
        - Create terrain rendering (walkable vs blocked)
        - Implement zone transitions via roads/signposts
        - Add gathering spots for raw materials
        - Create storage areas with dispensers
        - Implement delivery/scoring locations
      </tasks>
    </step>

    <step number="6">
      <title>Workshops and Crafting</title>
      <tasks>
        - Implement walk-into workshops (4x4+)
        - Create input/output/tool slot system
        - Implement recipe selection popup
        - Add recording system (capture movement path)
        - Implement playback for auto-repeat
        - Add crafting progress with delay formulas
        - Implement tool durability consumption
      </tasks>
    </step>

    <step number="7">
      <title>Tech Tree and Items</title>
      <tasks>
        - Import MonsterMakers tech tree (~80+ good types)
        - Implement quality system with visual brightness
        - Add durability system with visual indicators
        - Implement dispenser mechanics
        - Create weight system for transport
      </tasks>
    </step>

    <step number="8">
      <title>Economy and Skills</title>
      <tasks>
        - Implement renown system
        - Add share distribution for all contributors
        - Implement skill learning during work
        - Add skill forgetting over time
        - Implement monster upkeep
        - Add cost multiplier for spending
        - Implement monster aging bonuses
      </tasks>
    </step>

    <step number="9">
      <title>Visual Effects and Polish</title>
      <tasks>
        - Add crafting particles by type (sparks, steam, magic)
        - Implement progress bar for crafting
        - Add completion celebration effect
        - Implement deposit flash effect
        - Add quality glow for exceptional items
        - Implement durability red tint
        - Add speech bubbles for in-world messages
      </tasks>
    </step>

    <step number="10">
      <title>Multiplayer and Persistence</title>
      <tasks>
        - Ensure all players see each other's monsters
        - Implement offline auto-repeat continuation
        - Test and fix all multiplayer edge cases
        - Optimize tick processing for many entities
        - Add reconnection handling
      </tasks>
    </step>
  </implementation_steps>

  <success_criteria>
    <functionality>
      - Players can register, login, and control monsters
      - Monsters can move and push items on the grid
      - Crafting works via physical pushing of ingredients
      - Recording/playback system enables auto-repeat
      - Skills improve while working
      - Renown earned by delivering scored goods
      - Multiple players can see and interact in same world
      - Monsters continue working while player is offline
    </functionality>
    <user_experience>
      - Someone can pick up and play intuitively
      - Visual effects make actions feel satisfying
      - UI panels provide necessary info without menus
      - Speech bubbles communicate system state clearly
      - No confusion about what's happening
    </user_experience>
    <technical_quality>
      - Server-authoritative (no client-side cheating possible)
      - All game data is pure data (easy to iterate)
      - Clean separation between frontend (rendering) and backend (logic)
      - Proper error handling
      - Consistent tick processing
    </technical_quality>
    <design_polish>
      - Particles and effects for all major actions
      - Smooth animations for monster movement and working
      - Quality/durability clearly visible on items
      - Beautiful ASCII roguelike aesthetic
    </design_polish>
  </success_criteria>
</project_specification>
